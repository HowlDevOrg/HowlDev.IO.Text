using HowlDev.IO.Text.ConfigFile.Enums;
using HowlDev.IO.Text.ConfigFile.Interfaces;
using System.ComponentModel;
using System.Reflection;

namespace HowlDev.IO.Text.ConfigFile.Primitives;

/// <summary/>
[EditorBrowsable(EditorBrowsableState.Never)]
public class ArrayConfigOption : BaseConfigOption {
    private List<IBaseConfigOption> array = [];
    private string resourcePath;

    /// <inheritdoc/>
    public override ConfigOptionType Type => ConfigOptionType.Array;
    /// <inheritdoc/>
    public override int Count => array.Count;
    /// <inheritdoc/>
    public override IEnumerable<IBaseConfigOption> Items => array;

    /// <inheritdoc/>
    public ArrayConfigOption(List<IBaseConfigOption> array, string parentPath = "", string myPath = "") {
        this.array = array;
        resourcePath = parentPath;
        if (myPath.Length > 0) resourcePath += "[" + myPath + "]";
    }

    /// <inheritdoc/>
    public override IBaseConfigOption this[int index] {
        get {
            if (index < 0 || index >= array.Count) {
                string error = $"Index {index} is out of range. This array has {array.Count} items.";
                if (resourcePath.Length >= 3) error += $"\n\tPath: {resourcePath}";
                throw new ArgumentException(error);
            }

            return array[index];
        }
    }

    /// <inheritdoc/>
    public override IEnumerable<T> AsEnumerable<T>() => AsEnumerable<T>(new OptionMappingOptions() { UseProperties = true, UseConstructors = true });

    /// <inheritdoc/>
    public override IEnumerable<T> AsEnumerable<T>(OptionMappingOptions options) {
        List<T> values = [];
        // Generated by AI
        foreach (IBaseConfigOption value in array) {
            switch (value.Type) {
                case ConfigOptionType.Primitive:
                    values.Add(value.As<T>());
                    break;
                case ConfigOptionType.Object:
                    values.Add(ObjectConfigOption.Map<T>(options, value.Contains, value));
                    break;
                default:
                    throw new InvalidOperationException($"Cannot map array item of type {value.Type} to {typeof(T).Name}.");
            }
        }

        return values;
    }

    /// <inheritdoc />
    public override IEnumerable<T> AsStrictEnumerable<T>() {
        throw new NotImplementedException();
    }

    /// <inheritdoc/>
    public override object ToType(Type conversionType, IFormatProvider? provider) {
        if (typeof(Array).IsAssignableFrom(conversionType)
            || (conversionType.IsGenericType && conversionType.GetGenericTypeDefinition() == typeof(List<>))
            || (conversionType.IsGenericType && conversionType.GetGenericTypeDefinition() == typeof(IEnumerable<>))) {

            Type elementType;
            if (conversionType.IsArray) {
                elementType = conversionType.GetElementType()!;
            } else if (conversionType.IsGenericType) {
                elementType = conversionType.GetGenericArguments()[0];
            } else {
                throw new InvalidDataException("Cannot determine element type.");
            }

            MethodInfo? method = GetType().GetMethod(nameof(AsEnumerable), System.Type.EmptyTypes);
            MethodInfo genericMethod = method!.MakeGenericMethod(elementType);
            object result = genericMethod.Invoke(this, null)!;

            if (conversionType.IsArray) {
                MethodInfo toArrayMethod = typeof(Enumerable).GetMethod(nameof(Enumerable.ToArray))!.MakeGenericMethod(elementType);
                return toArrayMethod.Invoke(null, [result])!;
            }

            return result;
        }

        throw new InvalidDataException("Type conversion is not an enumerable.");
    }
}
